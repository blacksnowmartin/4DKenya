from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from dataclasses import dataclass, asdict
from typing import List, Dict
from collections import deque
import random
import time

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- CONFIG ---
GRID_SIZE = 20
TICK = 0

# --- MULTI-LAYER CITY STATE ---
# Layer 0: Buildings (static infrastructure)
# Layer 1: Population (residents/workers)
# Layer 2: Traffic (vehicle/data flow)
# Layer 3: Power (energy distribution)
# Layer 4: Heat/Pollution (environmental)
city_layers = [[0.0] * (GRID_SIZE * GRID_SIZE) for _ in range(5)]

# Initialize with random buildings
for i in range(GRID_SIZE * GRID_SIZE):
    city_layers[0][i] = random.random() * 0.4

@dataclass
class ScheduledEvent:
    id: int
    event_type: str
    execute_at: int
    params: Dict = None

event_counter = 0
event_queue: List[ScheduledEvent] = []
history = deque(maxlen=100)
anomaly_log = deque(maxlen=30)

def idx(x, y):
    return x * GRID_SIZE + y

def get_neighbor_avg(layer, x, y, radius=1):
    """Average value in neighborhood."""
    total = 0.0
    count = 0
    for dx in range(-radius, radius + 1):
        for dy in range(-radius, radius + 1):
            nx = (x + dx) % GRID_SIZE
            ny = (y + dy) % GRID_SIZE
            total += layer[idx(nx, ny)]
            count += 1
    return total / max(1, count)

def diffuse_layer(layer, rate=0.25):
    """Diffuse layer through neighbors."""
    new_layer = layer[:]
    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            neighbor_avg = get_neighbor_avg(layer, x, y, radius=1)
            new_layer[idx(x, y)] = layer[idx(x, y)] * (1 - rate) + neighbor_avg * rate
    return new_layer

def evolve_city():
    global TICK, city_layers, event_queue
    TICK += 1
    
    # 1. BUILDINGS stay static but slowly grow
    city_layers[0] = diffuse_layer(city_layers[0], 0.05)
    
    # 2. POPULATION dynamics (attracted to infrastructure)
    new_pop = []
    for i in range(GRID_SIZE * GRID_SIZE):
        infra = city_layers[0][i]
        pop = city_layers[1][i]
        # Population grows where buildings exist
        pop = pop * 0.9 + (infra * random.random() * 0.5)
        new_pop.append(min(1.0, pop))
    city_layers[1] = new_pop
    
    # 3. TRAFFIC (generated by population)
    new_traffic = []
    for i in range(GRID_SIZE * GRID_SIZE):
        x, y = i // GRID_SIZE, i % GRID_SIZE
        pop = city_layers[1][i]
        traffic = city_layers[2][i]
        # Traffic from population activity
        traffic = traffic * 0.65 + pop * random.random() * 0.6
        new_traffic.append(min(1.0, traffic))
    # Diffuse traffic to simulate flow
    city_layers[2] = diffuse_layer(new_traffic, 0.2)
    
    # 4. POWER consumption (based on activity)
    new_power = []
    for i in range(GRID_SIZE * GRID_SIZE):
        pop = city_layers[1][i]
        traffic = city_layers[2][i]
        power = city_layers[3][i]
        # Power demand from activity
        demand = pop * 0.4 + traffic * 0.3
        power = power * 0.7 + demand * random.random() * 0.7
        new_power.append(min(1.0, power))
    city_layers[3] = new_power
    
    # 5. HEAT/POLLUTION (from traffic & power)
    new_heat = []
    for i in range(GRID_SIZE * GRID_SIZE):
        traffic = city_layers[2][i]
        power = city_layers[3][i]
        heat = city_layers[4][i]
        # Heat from activity, decay slowly
        heat = heat * 0.8 + (traffic * 0.3 + power * 0.2) * random.random()
        new_heat.append(min(1.0, heat))
    city_layers[4] = new_heat
    
    # 6. RANDOM ACTIVITY INJECTIONS
    if random.random() > 0.6:
        for _ in range(2):
            x = random.randint(0, GRID_SIZE - 1)
            y = random.randint(0, GRID_SIZE - 1)
            city_layers[1][idx(x, y)] = min(1.0, city_layers[1][idx(x, y)] + random.random() * 0.6)
            city_layers[2][idx(x, y)] = min(1.0, city_layers[2][idx(x, y)] + random.random() * 0.7)
    
    # 7. PROCESS SCHEDULED EVENTS
    due = [e for e in event_queue if e.execute_at <= TICK]
    event_queue[:] = [e for e in event_queue if e.execute_at > TICK]
    for e in due:
        apply_event(e.event_type, e.params or {})
    
    # 8. ANOMALY DETECTION
    avg_traffic = sum(city_layers[2]) / len(city_layers[2])
    if avg_traffic > 0.75:
        anomaly_log.append({"tick": TICK, "type": "congestion", "value": avg_traffic})
    
    avg_heat = sum(city_layers[4]) / len(city_layers[4])
    if avg_heat > 0.65:
        anomaly_log.append({"tick": TICK, "type": "overheat", "value": avg_heat})

def apply_event(event_type: str, params: Dict):
    global city_layers
    if event_type == "surge":
        # Traffic surge everywhere
        city_layers[2] = [min(1.0, v + 0.6) for v in city_layers[2]]
    elif event_type == "blackout":
        # Kill power
        city_layers[3] = [0.0] * len(city_layers[3])
    elif event_type == "migration":
        # Population spike in center
        cx, cy = GRID_SIZE // 2, GRID_SIZE // 2
        for x in range(GRID_SIZE):
            for y in range(GRID_SIZE):
                dist = abs(x - cx) + abs(y - cy)
                if dist <= 4:
                    city_layers[1][idx(x, y)] = min(1.0, city_layers[1][idx(x, y)] + 0.5)
    elif event_type == "cool":
        # Reduce heat
        city_layers[4] = [v * 0.2 for v in city_layers[4]]
    elif event_type == "reset":
        for i in range(5):
            city_layers[i] = [random.random() * (0.4 if i == 0 else 0.1) for _ in range(GRID_SIZE * GRID_SIZE)]

def compute_metrics():
    metrics = {
        "avg_buildings": sum(city_layers[0]) / len(city_layers[0]),
        "avg_population": sum(city_layers[1]) / len(city_layers[1]),
        "avg_traffic": sum(city_layers[2]) / len(city_layers[2]),
        "avg_power": sum(city_layers[3]) / len(city_layers[3]),
        "avg_heat": sum(city_layers[4]) / len(city_layers[4]),
    }
    return metrics

# --- ENDPOINTS ---

@app.get("/city_pulse")
def get_pulse():
    evolve_city()
    metrics = compute_metrics()
    snapshot = {
        "tick": TICK,
        "buildings": city_layers[0],
        "population": city_layers[1],
        "traffic": city_layers[2],
        "power": city_layers[3],
        "heat": city_layers[4],
        "metrics": metrics,
        "size": GRID_SIZE
    }
    history.append(snapshot)
    return snapshot

@app.get("/city_status")
def city_status():
    metrics = compute_metrics()
    return {
        "tick": TICK,
        "metrics": metrics,
        "queued_events": len(event_queue),
        "recent_anomalies": list(anomaly_log)[-5:]
    }

@app.post("/schedule_event")
def schedule_event(event_type: str, delay: int = 1):
    global event_counter, event_queue
    if delay < 0:
        raise HTTPException(status_code=400, detail="Delay must be >= 0")
    event_counter += 1
    ev = ScheduledEvent(id=event_counter, event_type=event_type, execute_at=TICK + delay)
    event_queue.append(ev)
    return {"scheduled": asdict(ev)}

@app.post("/trigger_event")
def trigger_event(type: str):
    apply_event(type, {})
    return {"msg": f"Event {type} processed", "tick": TICK}

if __name__ == "__main__":
    print(f"--- NAIROBI DIGITAL TWIN ({GRID_SIZE}x{GRID_SIZE}) ADVANCED SIMULATION ONLINE ---")
    uvicorn.run(app, host="0.0.0.0", port=8000)