<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nairobi Protocol | Cyber Defense</title>
    <style>
        body { margin: 0; background-color: #050510; overflow: hidden; font-family: 'Segoe UI', monospace; user-select: none; }
        
        #ui-panel {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px;
            background: rgba(0, 0, 0, 0.8); border: 2px solid #00ffcc;
            padding: 10px 30px; border-radius: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
        }
        
        .stat { color: #00ffcc; font-size: 18px; font-weight: bold; }
        .label { font-size: 10px; color: #888; display: block; }
        
        #gameover {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; color: red; font-weight: bold; text-shadow: 0 0 30px red;
            display: none; pointer-events: none;
        }

        #controls { position: absolute; bottom: 20px; right: 20px; }
        button { background: #333; color: white; border: 1px solid #666; padding: 10px; cursor: pointer; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

    <div id="ui-panel">
        <div><span class="label">CREDITS</span><span class="stat" id="credits">0</span></div>
        <div><span class="label">SCORE</span><span class="stat" id="score">0</span></div>
        <div><span class="label">SYSTEM</span><span class="stat" id="status" style="color:cyan">SECURE</span></div>
    </div>

    <div id="gameover">SYSTEM BREACHED</div>
    
    <div id="controls">
        <button onclick="sendAction(0,0,'reset')">REBOOT SYSTEM</button>
    </div>

    <script>
        const GRID_SIZE = 15;
        const API = "http://localhost:8000";

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        
        const aspect = window.innerWidth / window.innerHeight;
        const d = 12;
        const camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(0,0,0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- BLOOM FX ---
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0; bloom.strength = 1.5; bloom.radius = 0.5;
        composer.addPass(bloom);

        // --- GAME OBJECTS ---
        
        // 1. GRID (For clicking)
        // We create invisible planes for the raycaster to hit
        const hitPlaneGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
        const hitPlaneMat = new THREE.MeshBasicMaterial({ visible: false });
        const hitPlane = new THREE.Mesh(hitPlaneGeo, hitPlaneMat);
        hitPlane.rotation.x = -Math.PI / 2; // Flat on floor
        scene.add(hitPlane);

        // Grid Lines Visual
        const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x004444, 0x002222);
        scene.add(gridHelper);

        // 2. TOWERS (Instanced Mesh)
        const tGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
        const tMat = new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x004444, roughness: 0.1 });
        const towers = new THREE.InstancedMesh(tGeo, tMat, GRID_SIZE*GRID_SIZE);
        scene.add(towers);

        // 3. ENEMIES (Simple red spheres)
        const eGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const eMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        // We will create individual meshes for enemies since they move smoothly
        let enemyMeshes = []; 

        // 4. THE CORE
        const coreGeo = new THREE.BoxGeometry(1, 3, 1);
        const coreMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4400, emissiveIntensity: 2 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        scene.add(core);

        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        // --- INTERACTION (RAYCASTING) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(hitPlane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                // Convert 3D world point to Grid Index
                const gx = Math.floor(point.x + GRID_SIZE/2);
                const gy = Math.floor(point.z + GRID_SIZE/2);
                
                if(gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                    sendAction(gx, gy, 'build');
                }
            }
        });

        // --- GAME LOOP ---
        async function gameLoop() {
            try {
                // 1. Fetch State
                const res = await fetch(`${API}/gameloop`);
                const data = await res.json();
                
                // 2. Update Stats
                document.getElementById('credits').innerText = data.stats.credits;
                document.getElementById('score').innerText = data.stats.score;
                
                if(data.stats.game_over) {
                    document.getElementById('gameover').style.display = 'block';
                    document.getElementById('status').innerText = "CRITICAL FAILURE";
                    document.getElementById('status').style.color = "red";
                } else {
                    document.getElementById('gameover').style.display = 'none';
                    document.getElementById('status').innerText = "DEFENDING...";
                    document.getElementById('status').style.color = "cyan";
                }

                // 3. Render Grid (Towers)
                let idx = 0;
                const grid = data.grid;
                for(let x=0; x<GRID_SIZE; x++) {
                    for(let z=0; z<GRID_SIZE; z++) {
                        const cell = grid[idx];
                        
                        if (cell === 1) { // TOWER
                            dummy.position.set(x - GRID_SIZE/2 + 0.5, 0.5, z - GRID_SIZE/2 + 0.5);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            towers.setMatrixAt(idx, dummy.matrix);
                        } else {
                            // Hide empty cells by scaling to 0
                            dummy.position.set(0, -10, 0);
                            dummy.scale.set(0,0,0);
                            dummy.updateMatrix();
                            towers.setMatrixAt(idx, dummy.matrix);
                        }
                        idx++;
                    }
                }
                towers.instanceMatrix.needsUpdate = true;

                // 4. Render Enemies
                // Clear old meshes
                enemyMeshes.forEach(m => scene.remove(m));
                enemyMeshes = [];
                
                data.enemies.forEach(e => {
                    const mesh = new THREE.Mesh(eGeo, eMat);
                    mesh.position.set(e.x - GRID_SIZE/2 + 0.5, 0.5, e.y - GRID_SIZE/2 + 0.5);
                    scene.add(mesh);
                    enemyMeshes.push(mesh);
                });

            } catch(e) { console.log(e); }
        }

        async function sendAction(x, y, type) {
            await fetch(`${API}/action?x=${x}&y=${y}&type=${type}`, { method: 'POST' });
        }

        // Run Logic Loop every 100ms
        setInterval(gameLoop, 100);

        // Run Render Loop (60fps)
        function animate() {
            requestAnimationFrame(animate);
            // Pulse the Core
            const time = Date.now() * 0.005;
            core.scale.set(1 + Math.sin(time)*0.1, 3, 1 + Math.sin(time)*0.1);
            
            composer.render();
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
             const aspect = window.innerWidth / window.innerHeight;
             camera.left = -d * aspect; camera.right = d * aspect;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
             composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>