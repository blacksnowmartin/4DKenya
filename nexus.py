from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from dataclasses import dataclass, asdict
from typing import List, Dict
from collections import deque
import random
import time

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- CONFIG ---
GRID_SIZE = 24
TICK = 0

# --- MULTI-LAYER CITY STATE ---
# Layer 0: Building height (infrastructure)
# Layer 1: Population density
# Layer 2: Traffic/Data flow
# Layer 3: Pollution/Heat
# Layer 4: Energy consumption
city_layers = [[0.0] * (GRID_SIZE * GRID_SIZE) for _ in range(5)]

# Initialize with some random infrastructure
for i in range(GRID_SIZE * GRID_SIZE):
    city_layers[0][i] = random.random() * 0.3

@dataclass
class ScheduledEvent:
    id: int
    type: str
    execute_at: int
    params: Dict = None

event_counter = 0
event_queue: List[ScheduledEvent] = []
history = deque(maxlen=200)
anomaly_log = deque(maxlen=50)

def idx(x, y):
    return x * GRID_SIZE + y

def get_neighborhood(layer, x, y, radius=1):
    """Get average value from neighborhood."""
    total = 0.0
    count = 0
    for dx in range(-radius, radius + 1):
        for dy in range(-radius, radius + 1):
            nx, ny = (x + dx) % GRID_SIZE, (y + dy) % GRID_SIZE
            total += layer[idx(nx, ny)]
            count += 1
    return total / max(1, count)

def diffuse_layer(layer, diffusion_rate=0.3):
    """Spread values through diffusion."""
    new_layer = layer[:]
    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            neighbor_avg = get_neighborhood(layer, x, y, radius=1)
            new_layer[idx(x, y)] = layer[idx(x, y)] * (1 - diffusion_rate) + neighbor_avg * diffusion_rate
    return new_layer

def evolve_system():
    global TICK, city_layers, event_queue
    TICK += 1
    
    # 1. INFRASTRUCTURE GROWTH (very slow)
    city_layers[0] = diffuse_layer(city_layers[0], 0.1)
    
    # 2. POPULATION DYNAMICS (affected by infrastructure)
    new_pop = []
    for i in range(GRID_SIZE * GRID_SIZE):
        x, y = i // GRID_SIZE, i % GRID_SIZE
        # Population grows where there's infrastructure
        infra = city_layers[0][i]
        pop = city_layers[1][i]
        pop = pop * 0.95 + (infra * random.random() * 0.4)
        new_pop.append(min(1.0, pop))
    city_layers[1] = new_pop
    
    # 3. TRAFFIC FLOW (population generates traffic)
    new_traffic = []
    for i in range(GRID_SIZE * GRID_SIZE):
        x, y = i // GRID_SIZE, i % GRID_SIZE
        pop = city_layers[1][i]
        traffic = city_layers[2][i]
        # Traffic is generated by population and spreads
        traffic = traffic * 0.6 + pop * random.random() * 0.5
        new_traffic.append(min(1.0, traffic))
    city_layers[2] = diffuse_layer(new_traffic, 0.2)
    
    # 4. POLLUTION (result of traffic and energy use)
    new_pollution = []
    for i in range(GRID_SIZE * GRID_SIZE):
        traffic = city_layers[2][i]
        energy = city_layers[4][i]
        pollution = city_layers[3][i]
        # Pollution increases with activity, decays slowly
        pollution = pollution * 0.85 + (traffic * 0.3) + (energy * 0.2)
        new_pollution.append(min(1.0, pollution))
    city_layers[3] = new_pollution
    
    # 5. ENERGY CONSUMPTION
    new_energy = []
    for i in range(GRID_SIZE * GRID_SIZE):
        x, y = i // GRID_SIZE, i % GRID_SIZE
        pop = city_layers[1][i]
        traffic = city_layers[2][i]
        energy = city_layers[4][i]
        # Energy demand based on activity
        demand = pop * 0.4 + traffic * 0.3
        energy = energy * 0.7 + demand * random.random() * 0.6
        new_energy.append(min(1.0, energy))
    city_layers[4] = new_energy
    
    # 6. RANDOM ACTIVITY INJECTIONS
    if random.random() > 0.7:
        for _ in range(3):
            x, y = random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1)
            city_layers[1][idx(x, y)] = min(1.0, city_layers[1][idx(x, y)] + random.random() * 0.5)
            city_layers[2][idx(x, y)] = min(1.0, city_layers[2][idx(x, y)] + random.random() * 0.6)
    
    # 7. PROCESS SCHEDULED EVENTS
    due = [e for e in event_queue if e.execute_at <= TICK]
    event_queue[:] = [e for e in event_queue if e.execute_at > TICK]
    for e in due:
        apply_event(e.type, e.params or {})
    
    # 8. ANOMALY DETECTION
    avg_traffic = sum(city_layers[2]) / len(city_layers[2])
    if avg_traffic > 0.7:
        anomaly_log.append({"tick": TICK, "type": "high_traffic", "value": avg_traffic})
    
    avg_pollution = sum(city_layers[3]) / len(city_layers[3])
    if avg_pollution > 0.6:
        anomaly_log.append({"tick": TICK, "type": "pollution_spike", "value": avg_pollution})

def apply_event(event_type: str, params: Dict):
    global city_layers
    if event_type == "infrastructure_boost":
        # Boost building height in region
        cx, cy = params.get("x", GRID_SIZE // 2), params.get("y", GRID_SIZE // 2)
        for x in range(GRID_SIZE):
            for y in range(GRID_SIZE):
                dist = abs(x - cx) + abs(y - cy)
                if dist <= params.get("radius", 3):
                    city_layers[0][idx(x, y)] = min(1.0, city_layers[0][idx(x, y)] + 0.4)
    
    elif event_type == "population_surge":
        # Inject population
        cx, cy = params.get("x", GRID_SIZE // 2), params.get("y", GRID_SIZE // 2)
        for x in range(GRID_SIZE):
            for y in range(GRID_SIZE):
                dist = abs(x - cx) + abs(y - cy)
                if dist <= params.get("radius", 2):
                    city_layers[1][idx(x, y)] = min(1.0, city_layers[1][idx(x, y)] + 0.5)
    
    elif event_type == "blackout":
        # Crash energy
        city_layers[4] = [0.0] * len(city_layers[4])
    
    elif event_type == "clean_air":
        # Reduce pollution sharply
        city_layers[3] = [v * 0.1 for v in city_layers[3]]
    
    elif event_type == "ddos":
        # Spike traffic everywhere
        city_layers[2] = [min(1.0, v + 0.8) for v in city_layers[2]]
    
    elif event_type == "reset":
        for i in range(5):
            city_layers[i] = [random.random() * (0.3 if i == 0 else 0.1) for _ in range(GRID_SIZE * GRID_SIZE)]

def compute_metrics():
    """Compute city-wide metrics."""
    metrics = {
        "avg_infrastructure": sum(city_layers[0]) / len(city_layers[0]),
        "avg_population": sum(city_layers[1]) / len(city_layers[1]),
        "avg_traffic": sum(city_layers[2]) / len(city_layers[2]),
        "avg_pollution": sum(city_layers[3]) / len(city_layers[3]),
        "avg_energy": sum(city_layers[4]) / len(city_layers[4]),
    }
    # Find hotspots
    hotspots = sorted(
        [(i, city_layers[2][i]) for i in range(len(city_layers[2]))],
        key=lambda x: x[1], reverse=True
    )[:5]
    metrics["traffic_hotspots"] = [{"idx": idx, "traffic": val} for idx, val in hotspots]
    return metrics

@app.get("/nexus_pulse")
def get_pulse():
    evolve_system()
    metrics = compute_metrics()
    snapshot = {
        "tick": TICK,
        "buildings": city_layers[0],
        "population": city_layers[1],
        "traffic": city_layers[2],
        "pollution": city_layers[3],
        "energy": city_layers[4],
        "metrics": metrics,
        "dim": GRID_SIZE
    }
    history.append(snapshot)
    return snapshot

@app.get("/nexus_status")
def nexus_status():
    metrics = compute_metrics()
    return {
        "tick": TICK,
        "metrics": metrics,
        "queued_events": len(event_queue),
        "recent_anomalies": list(anomaly_log)[-10:]
    }

@app.post("/schedule_event")
def schedule_event(type: str, delay: int = 1, x: int = None, y: int = None, radius: int = 3):
    global event_counter, event_queue
    if delay < 0:
        raise HTTPException(status_code=400, detail="Delay must be >= 0")
    event_counter += 1
    params = {"x": x or GRID_SIZE // 2, "y": y or GRID_SIZE // 2, "radius": radius}
    ev = ScheduledEvent(id=event_counter, type=type, execute_at=TICK + delay, params=params)
    event_queue.append(ev)
    return {"scheduled": asdict(ev)}

@app.get("/history")
def get_history(limit: int = 50):
    return list(history)[-limit:]

@app.post("/hack_event")
def hack_event(type: str, x: int = None, y: int = None, radius: int = 3):
    apply_event(type, {"x": x or GRID_SIZE // 2, "y": y or GRID_SIZE // 2, "radius": radius})
    return {"status": "ACK", "tick": TICK}

if __name__ == "__main__":
    print("--- NAIROBI NEURAL NEXUS ONLINE (Advanced Multi-Layer Simulation) ---")
    uvicorn.run(app, host="0.0.0.0", port=8000)