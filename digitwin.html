<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nairobi 4.0 | Neural Digital Twin</title>
    <style>
        body { margin: 0; background-color: #050510; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 280px;
            background: rgba(10, 10, 20, 0.9); border-left: 3px solid #00aaff;
            padding: 20px; box-shadow: 0 0 20px rgba(0, 170, 255, 0.3);
        }
        
        h1 { margin: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; color: #00aaff; }
        p { font-size: 12px; color: #888; margin-bottom: 20px; }
        
        button {
            width: 100%; padding: 10px; margin-bottom: 8px; border: none; font-weight: bold;
            text-transform: uppercase; cursor: pointer; transition: 0.2s; font-size: 11px;
        }
        
        .btn-boost { background: #00aaff; color: #000; }
        .btn-boost:hover { background: #fff; }
        
        .btn-kill { background: #ff3333; color: #fff; }
        .btn-kill:hover { background: #ff0000; }
        
        .btn-reset { background: #333; color: #fff; }
        
        #status { font-size: 10px; margin-top: 10px; color: #00ff00; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>Nairobi 4.0</h1>
        <p>NEURAL DIGITAL TWIN</p>
        
        <button class="btn-boost" onclick="trigger('boost')">⚡ Inject Infrastructure</button>
        <button class="btn-kill" onclick="trigger('blackout')">⚠ Grid Failure</button>
        <button class="btn-reset" onclick="trigger('reset')">↻ Randomize Layout</button>
        
        <div id="status">● CONNECTED TO NEURAL CORE</div>
    </div>

    <script>
        // --- CONFIG ---
        const GRID_SIZE = 16;
        const TOTAL_CELLS = GRID_SIZE * GRID_SIZE;
        const API_URL = "http://localhost:8000";

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        // Soft fog for depth
        scene.fog = new THREE.Fog(0x050510, 10, 25);

        // ISOMETRIC CAMERA (SimCity Look)
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- INSTANCED MESH (High Performance City) ---
        // We create ONE geometry and replicate it 256 times
        const geometry = new THREE.BoxGeometry(0.8, 1, 0.8);
        const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const cityMesh = new THREE.InstancedMesh(geometry, material, TOTAL_CELLS);
        
        scene.add(cityMesh);

        // Define positions for the grid
        const dummy = new THREE.Object3D();
        let index = 0;
        
        // Initial Layout (Flat)
        for(let x = 0; x < GRID_SIZE; x++) {
            for(let z = 0; z < GRID_SIZE; z++) {
                dummy.position.set(x - GRID_SIZE/2, 0, z - GRID_SIZE/2);
                dummy.updateMatrix();
                cityMesh.setMatrixAt(index++, dummy.matrix);
            }
        }

        // --- ANIMATION LOOP ---
        async function animate() {
            requestAnimationFrame(animate);

            try {
                // 1. Fetch the Neural Grid from Python
                const res = await fetch(`${API_URL}/city_pulse`);
                const json = await res.json();
                const gridData = json.grid;

                // 2. Update the City based on Data
                let idx = 0;
                for(let x = 0; x < GRID_SIZE; x++) {
                    for(let z = 0; z < GRID_SIZE; z++) {
                        const value = gridData[idx]; // Value 0.0 to 1.0

                        // Position: Centered grid
                        dummy.position.set(x - GRID_SIZE/2, value * 2, z - GRID_SIZE/2);
                        
                        // Scale: Height depends on neural activation (High value = Skyscraper)
                        dummy.scale.set(1, Math.max(0.1, value * 5), 1);
                        
                        dummy.updateMatrix();
                        cityMesh.setMatrixAt(idx, dummy.matrix);

                        // Color: Low = Dark Blue, High = Bright Cyan/White
                        const color = new THREE.Color();
                        // Lerp between Blue (0x000033) and Cyan (0x00aaff)
                        color.setHSL(0.6, 1.0, value * 0.5 + 0.1); 
                        cityMesh.setColorAt(idx, color);

                        idx++;
                    }
                }
                
                cityMesh.instanceMatrix.needsUpdate = true;
                cityMesh.instanceColor.needsUpdate = true;
                
                document.getElementById('status').innerText = "● LIVE DATA STREAMING";
                document.getElementById('status').style.color = "#00ff00";

            } catch (e) {
                document.getElementById('status').innerText = "⚠ DISCONNECTED";
                document.getElementById('status').style.color = "#ff0000";
            }

            // Slow Rotation of the whole city
            scene.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }

        async function trigger(type) {
            await fetch(`${API_URL}/trigger_event?type=${type}`, { method: 'POST' });
        }

        animate();
        
        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
